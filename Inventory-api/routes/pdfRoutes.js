const express = require('express');
const { jsPDF } = require('jspdf');
require('jspdf-autotable');
const fs = require('fs');
const path = require('path');

const router = express.Router();

// Assurez-vous que le répertoire "downloads" existe
const downloadsDir = path.join(__dirname, 'downloads');
if (!fs.existsSync(downloadsDir)) {
    fs.mkdirSync(downloadsDir);
}

// Route 1: Générer un rapport d'inventaire en PDF
router.post('/generate-pdf', async (req, res) => {
    try {
        const { vehicles = [], phones = [], batteries = [], userName = 'Unknown User' } = req.body;

        const doc = new jsPDF();
        const formattedDate = new Date().toISOString().split('T')[0];
        const fileName = `Inventory_${formattedDate}.pdf`;

        // Titre principal
        doc.setFont('helvetica', 'bold');
        doc.setFontSize(20);
        doc.text('Inventory Report', 10, 20);

        // Informations générales
        doc.setFontSize(12);
        doc.setFont('helvetica', 'normal');
        doc.text(`Generated by: ${userName}`, 10, 30);
        doc.text(`Date: ${formattedDate}`, 10, 37);

        // Section véhicules
        const vehiclesStartY = 45;
        doc.setFontSize(16);
        doc.text('Vehicles', 10, vehiclesStartY);

        if (vehicles.length > 0) {
            doc.autoTable({
                startY: vehiclesStartY + 5,
                head: [['Name', 'Key', 'ShellCard', 'Paper', 'Cable', 'Status']],
                body: vehicles.map((v) => [
                    v.name,
                    v.key ? 'Yes' : 'No',
                    v.shellCard ? 'Yes' : 'No',
                    v.paper ? 'Yes' : 'No',
                    v.cable ? 'Yes' : 'No',
                    v.status || 'N/A',
                ]),
            });
        } else {
            doc.text('No vehicles available.', 10, vehiclesStartY + 10);
        }

        // Section téléphones
        const phonesStartY = doc.lastAutoTable ? doc.lastAutoTable.finalY + 10 : vehiclesStartY + 20;
        doc.setFontSize(16);
        doc.text('Phones', 10, phonesStartY);

        if (phones.length > 0) {
            doc.autoTable({
                startY: phonesStartY + 5,
                head: [['Name', 'Exists', 'Status']],
                body: phones.map((p) => [
                    p.name,
                    p.exists ? 'Yes' : 'No',
                    p.status || 'N/A',
                ]),
            });
        } else {
            doc.text('No phones available.', 10, phonesStartY + 10);
        }

        // Section batteries
        const batteriesStartY = doc.lastAutoTable ? doc.lastAutoTable.finalY + 10 : phonesStartY + 20;
        doc.setFontSize(16);
        doc.text('Batteries', 10, batteriesStartY);

        if (batteries.length > 0) {
            doc.autoTable({
                startY: batteriesStartY + 5,
                head: [['Name', 'Exists', 'Status']],
                body: batteries.map((b) => [
                    b.name,
                    b.exists ? 'Yes' : 'No',
                    b.status || 'N/A',
                ]),
            });
        } else {
            doc.text('No batteries available.', 10, batteriesStartY + 10);
        }

        // Sauvegarde du PDF
        const pdfPath = path.join(downloadsDir, fileName);
        fs.writeFileSync(pdfPath, doc.output());

        // Envoi du fichier au client
        res.download(pdfPath, fileName, (err) => {
            if (err) {
                console.error('Error sending PDF:', err);
                res.status(500).send('Error downloading PDF.');
            }
            fs.unlink(pdfPath, (unlinkErr) => {
                if (unlinkErr) console.error('Error deleting PDF:', unlinkErr);
            });
        });
    } catch (error) {
        console.error('Error generating PDF:', error);
        res.status(500).send('Error generating PDF.');
    }
});

// Route 2: Générer un rapport TimeCard en PDF
router.post('/timecard-pdf', async (req, res) => {
    try {
        const { timeCards = [], employees = {}, date = 'Unknown Date', userName = 'Unknown User' } = req.body;

        const doc = new jsPDF();
        const fileName = `TimeCard_${date}.pdf`;

        // Titre principal
        doc.setFont('helvetica', 'bold');
        doc.setFontSize(20);
        doc.text('TimeCard Report', 10, 20);

        // Informations générales
        doc.setFontSize(12);
        doc.setFont('helvetica', 'normal');
        doc.text(`Generated by: ${userName}`, 10, 30);
        doc.text(`Date: ${date}`, 10, 37);

        // Tableau TimeCard
        const startY = 45;
        doc.autoTable({
            startY,
            head: [['Employee', 'Start Time', 'Last Delivery', 'End Time', 'TEL', 'Battery', 'Comment']],
            body: timeCards.map((card) => {
                const employee = employees[card.employeeId];
                const fullName = employee ? `${employee.name} ${employee.familyName}` : 'Unknown';
                return [
                    fullName,
                    card.startTime || 'N/A',
                    card.lastDelivery || 'N/A',
                    card.endTime || 'N/A',
                    card.tel || 'N/A',
                    card.powerbank || 'N/A',
                    card.comment || 'No comment',
                ];
            }),
        });

        // Sauvegarde du PDF
        const pdfPath = path.join(downloadsDir, fileName);
        fs.writeFileSync(pdfPath, doc.output());

        // Envoi du fichier au client
        res.download(pdfPath, fileName, (err) => {
            if (err) {
                console.error('Error sending PDF:', err);
                res.status(500).send('Error downloading PDF.');
            }
            fs.unlink(pdfPath, (unlinkErr) => {
                if (unlinkErr) console.error('Error deleting PDF:', unlinkErr);
            });
        });
    } catch (error) {
        console.error('Error generating PDF:', error);
        res.status(500).send('Error generating PDF.');
    }
});

module.exports = router;
